---
pagination_next: main/create-new-template/settings
pagination_prev: main/create-new-template/packages
sidebar_position: 3
---

import { Example } from '@site/docs/components/example';
import { Dot } from '@site/docs/components/dot';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Dynamic Files

:::caution

If you not using a version of templates above `1.1.0`, please refer to the
[legacy docs](./dynamic-files-legacy)

:::

## Dynamic files breakdown

Dynamic file are files that can be rendered with dynamic data. You can think of
these files sort of like how template engines work. You use a special syntax
than then gets replaced with data you provide. This output then gets saved into
the file where this instance is being generated.

<Example open>

A file with these contents

```text
{{= tps.answers.name }} wants some more cake
```

will produce:

```text
lino wants some more cake
```

Dont worry about the specifics, well touch more on the syntax later on this page

</Example>

## Template engine

Like mentioned before our in house template engine was forked from
[doT](http://olado.github.io/doT/index.html). However we add some more
capabilities in order to fit templates needs better.

mention: strictness of white space

Our template engine has two main syntaxes: `inline` and `block`

### Inline syntax

Inline syntax is implemented using two curly brackets at both the start and end
of your expression `{{ ... }}`. This syntax is more flexable and recommended
when dealing with different control flows inline.

Take this template that is using a inline if statement to conditionally add a
typescript type to the variable.

<Dot
	tps={{ 
		answers: {
			typescript: true,
		},
	}}
	lang="typescript"
>

```
const name{{? tps.answers.typescript }}: string{{?}} = 'lino';
```

</Dot>

:::tip

We will be using references to the [templates context](#templates-context)
object like `tps.`, `tps.answers.`, and `tps.utils.` all thoughout these doc.
However we dont touch on this object until
[later on in this guide](#templates-context). Just keep in mind that `utils` is
a collection of helper functions to make creating dynamic templates easier, and
`answers` allows users of your template to pass in data to customize their
instance

:::

### Block syntax

Block syntax is implemented using three curly brackets at both the start and end
of your expression `{{{ ... }}}`. The main differences is that block syntax
needs to be placeds on a new line and it will remove all white space in front
and behind the brackets completely removing the line from output.

Take this example using a block if statement, when `css` is `false` notice how
there no is trace that anything was there before, no new lines, no spaces,
nothing it was completely wiped.

<Dot
	tps={{ 
		answers: {
			css: false
		}
	}}
	lang="typescript"
	templateMeta='{2-4}'
>

```
import React from 'react';
{{{? tps.answers.css }}}
import './component.css';
{{{?}}}
```

</Dot>

You can also indent block syntax and all tabs and spaces will be removed

<Dot
	tps={{ 
		answers: {
			css: false
		}
	}}
	lang="typescript"
	templateMeta='{2-4}'
>

```
const App = () => {
	{{{? tps.answers.state }}}
	const [state, setState] = useState(null);
	{{{?}}}

	return (
		/* other code ... */
	)
}
```

</Dot>

<Example title='Why is there inline and block?'>

Block syntax plays a special role in file generation. By removing all existence
of white space, your rendered output looks nice and clean. Templates aims to not
only make development eaiser but also enforce standards.

Before block syntax there was only inline syntax, however there was a lot of
issues with the way these tags got parsed that left outputed files with
unindented whitespace.

**example:**

lets use the example template from above and change block syntax to inline
syntax. Now when `css` & `state` are `false`, notice how there is extra
whitespace behind

<Dot
	tps={{ 
		answers: {
			css: false,
			state: false
		}
	}}
	lang="typescript"
	templateMeta='{2-4,7-9}'
	resultMeta="{2,5}"
>

```
import React from 'react';
{{? tps.answers.css }}
import './component.css';
{{?}}

const App = () => {
	{{? tps.answers.state }}
	const [state, setState] = useState(null);
	{{?}}

	return (
		/* other code ... */
	)
}
```

</Dot>

Now when `css` & `state` are `true`, you can also see extra lines.

<Dot
	tps={{ 
		answers: {
			css: true,
			state: true
		}
	}}
	lang="typescript"
	resultMeta="{2,4,7,9}"
	displayTemplate={false}
>

```
import React from 'react';
{{? tps.answers.css }}
import './component.css';
{{?}}

const App = () => {
	{{? tps.answers.state }}
	const [state, setState] = useState(null);
	{{?}}

	return (
		/* other code ... */
	)
}
```

</Dot>

In order to get the perfect output, you needed to sacrafice the readability of
the template and do something like the following:

<Dot
	tps={{ 
		answers: {
			css: false,
			state: false
		}
	}}
	lang="typescript"
	templateMeta='{2-3,5-6}'
	resultMeta='{2,4}'
>

```
import React from 'react';
{{? tps.answers.css }}import './component.css';
{{?}}
const App = () => {
	{{? tps.answers.state }}const [state, setState] = useState(null);
	{{?}}
	return (
		/* other code ... */
	)
}
```

</Dot>

Now when `css` & `state` are `true`, you can also see extra lines.

<Dot
	tps={{ 
		answers: {
			css: true,
			state: true
		}
	}}
	lang="typescript"
	displayTemplate={false}
	resultMeta='{3,6}'
>

```
import React from 'react';
{{? tps.answers.css }}import './component.css';
{{?}}
const App = () => {
	{{? tps.answers.state }}const [state, setState] = useState(null);
	{{?}}
	return (
		/* other code ... */
	)
}
```

</Dot>

While this might not look the worst for one answer, imagine 3 or 4. Now lets see
how block syntax improves this:

<Dot
	tps={{ 
		answers: {
			css: false,
			state: false,
		}
	}}
	lang="typescript"
	templateMeta='{2-4,7-9}'
	resultMeta='{2,4}'
>

```
import React from 'react';
{{{? tps.answers.css }}}
import './component.css';
{{{?}}}

const App = () => {
	{{{? tps.answers.state }}}
	const [state, setState] = useState(null);
	{{{?}}}

	return (
		/* other code ... */
	)
}
```

</Dot>

Now when `css` & `state` are `true`,

<Dot
	tps={{ 
		answers: {
			css: true,
			state: true,
		}
	}}
	lang="typescript"
	displayTemplate={false}
	resultMeta='{3,6}'
>

```
import React from 'react';
{{{? tps.answers.css }}}
import './component.css';
{{{?}}}

const App = () => {
	{{{? tps.answers.state }}}
	const [state, setState] = useState(null);
	{{{?}}}

	return (
		/* other code ... */
	)
}
```

</Dot>

</Example>

## Template Syntaxes

### Evaluation

Evaluation is achieved using `{{ <expression> }}`. The `expression` can be any
valid JavaScript expression. You can create variables, functions, and etc. **The
semi-colon at the end of the expression is mandatory!**

:::tip

While you can use inline evaluations, we recommned using block evaluations to
avoid unintended white space

:::

<Tabs>
<TabItem value="block" label="Block">
</TabItem>

<TabItem value="inline" label="Inline">
</TabItem>
</Tabs>

---

<Tabs>

<TabItem value="block" label="Block">
<Dot
	templateMeta='{1-4}'
>

```text
{{{
	const name = "Marcellino Ornelas";
	const age = 21;
}}}
Hello my name is {{= name }} and my age is {{= age }}
```

</Dot>
</TabItem>

<TabItem value="inline" label="Inline">
<Dot
 	templateMeta='{1}'
>

```text
{{ const name = "Marcellino Ornelas"; }}
{{= name }}
```

</Dot>
</TabItem>

</Tabs>

Checkout our [API docs](../../api/template-engine/evaluation) for more examples
on how you can take advantage of evaluations

### Interpolation

Interpolation is achieved using equal sign operator `=` along with the inline or
block brackets. This opertator allows you to render dynamic output into the file
contents.

<Tabs>
<TabItem value="block" label="Block">

<Dot>

```text
// highlight-next-line
{{= 2 + 2}}
```

</Dot>

</TabItem>

<TabItem value="inline" label="Inline">

<Dot>

```text
// highlight-next-line
{{= 2 + 2}}
```

</Dot>

</TabItem>
</Tabs>

Checkout our [API docs](../../api/template-engine/interpolation) for more
examples on how you can take advantage of interpolations

### Conditionals

Conditionals are achieved using the `?` operator along with inline or block
brackets. The result of the provided expression will be rendered into the output
of the file when the expression returns a truthy value

<Tabs>
<TabItem value="block" label="Block">

Take this template below that is using a block if statement to conditionally
render an css import when the `css` answer is `true`

<Dot
	tps={{name: "react-component", answers: {css: true}}} 
	lang="typescript"
	templateMeta='{2-4}'
	resultMeta='{2}'
>

```text
import React from 'react';
{{{? tps.answers.css }}}
import "styles.css";
{{{?}}}
```

</Dot>

Now when `css` is `false`

<Dot
	tps={{name: "react-component", answers: {css: false}}} 
	lang="typescript"
	displayTemplate={false}
>

```text
import React from 'react';
{{{? tps.answers.css }}}
import "styles.css";
{{{?}}}
```

</Dot>

</TabItem>

<TabItem value="inline" label="Inline">

Take this template that is using a inline if statement to conditionally add a
typescript type to the variable when the `typescript` answer is `true`

<Dot 
	lang="typescript"
	tps={{name: "react-component", answers: {typescript: true}}}
>

```text
const name{{? tps.answers.typescript }}: string{{?}} = 'lino';
```

</Dot>

Now when `typescript` is `false`

<Dot
	tps={{name: "react-component", answers: {typescript: false}}}
	lang="typescript"
	displayTemplate={false}
>

```text
const name{{? tps.answers.typescript }}: string{{?}} = 'lino';
```

</Dot>

</TabItem>
</Tabs>

#### Else

You can also write else statements by adding an additional inline or block
brackets that contains the two question mark operators `??`.

<Tabs>
<TabItem value="block" label="Block">

Take this template that is using a block if else statement to conditionally
render a import statement that would be compatible with css modules when
`cssLang` is `modules` else will render a normal css import statement.

<Dot
	lang="typescript"
	tps={{name: "footer", answers: { cssLang: "modules"}}}
	templateMeta='{2-6}'
	resultMeta='{2}'
>

```text
import React from 'react';
{{{? tps.answers.cssLang === 'modules'}}}
import styles from './{{= tps.name}}.css';
{{{??}}}
import './{{= tps.name}}.css';
{{{?}}}
```

</Dot>

Now when `cssLang` is **not** `modules`

<Dot
	lang="typescript"
	tps={{name: "footer", answers: { cssLang: "less"}}}
	displayTemplate={false}
	resultMeta='{2}'
>

```text
import React from 'react';
{{{? tps.answers.cssLang === 'modules'}}}
import styles from './{{= tps.name}}.css';
{{{??}}}
import './{{= tps.name}}.css';
{{{?}}}
```

</Dot>

</TabItem>

<TabItem value="inline" label="Inline">

Take this template that is using a inline if else statement to conditionally
render a dynamic tag name when present else will render a `div`.

<Dot
	tps={{name: "react-component", answers: { component: "Page" }}}
	lang="tsx"
	templateMeta='{3,5}'
>

```text
const App = () => {
	return (
		<{{? tps.answers.component }}{{= tps.answers.component }}{{??}}div{{?}}>
			/* contents... */
		</{{? tps.answers.component }}{{= tps.answers.component }}{{??}}div{{?}}>
	);
};
```

</Dot>

</TabItem>
</Tabs>

#### Else if

You can also write else statements by adding an additional inline or block
brackets that contains the two question mark operators `??` with a expression
afterwards.

<Tabs>
<TabItem value="block" label="Block">

Take this template using a block if statement to conditonally render a
compatible css module import when `cssLang` is `modules`.

<Dot
	lang="typescript" 
	tps={{name: "footer", answers: { cssLang: "modules", css: true}}}
	templateMeta='{4-5}'
>

```text
import React from 'react';
{{{? tps.answers.cssLang === 'modules'}}}
import styles from './{{= tps.name}}.css'
{{{?? tps.answers.css }}}
import from './{{= tps.name}}.css'
{{{?}}}
```

</Dot>

Now when `cssLang` is not `modules` and `css` is `true` then you will get the
following:

<Dot
	lang="typescript" 
	tps={{name: "footer", answers: { cssLang: "other", css: true}}}
	templateMeta='{4-5}'
	displayTemplate={false}
>

```text
import React from 'react';
{{{? tps.answers.cssLang === 'modules'}}}
import styles from './{{= tps.name}}.css'
{{{?? tps.answers.css }}}
import from './{{= tps.name}}.css'
{{{?}}}
```

</Dot>

Lastly when `cssLang` is not `modules` and `css` is `false` then you will get no
rendered output

<Dot
	lang="typescript" 
	tps={{name: "footer", answers: { cssLang: "other", css: false}}}
	templateMeta='{4-5}'
	displayTemplate={false}
>

```text
import React from 'react';
{{{? tps.answers.cssLang === 'modules'}}}
import styles from './{{= tps.name}}.css'
{{{?? tps.answers.css }}}
import from './{{= tps.name}}.css'
{{{?}}}
```

</Dot>

</TabItem>

<TabItem value="inline" label="Inline">

Take this template using a inline if statement to conditonally render the
`PageComponent` with a `block` prop when the `component` answer is `page`.

<Dot
	tps={{name: "react-component", answers: { component: "page" }}}
	lang="tsx"
	templateMeta='{3}'
>

```text
const App = () => {
	return (
		<{{? tps.answers.component === 'page' }}PageComponent block{{?? tps.answers.component }}{{= tps.answers.component }}{{??}}div{{?}}>
			/* contents... */
		</{{? tps.answers.component === 'page' }}PageComponent{{?? tps.answers.component }}{{= tps.answers.component }}{{??}}div{{?}}>
	)
};
```

</Dot>

Now when the `component` answer is not `page`, it will use whatever the user
passed into it. In this case we passed in `Box`.

<Dot
	tps={{name: "react-component", answers: { component: "Box" }}}
	lang="tsx"
	templateMeta='{3}'
	displayTemplate={false}
>

```text
const App = () => {
	return (
		<{{? tps.answers.component === 'page' }}PageComponent block{{?? tps.answers.component }}{{= tps.answers.component }}{{??}}div{{?}}>
			/* contents... */
		</{{? tps.answers.component === 'page' }}PageComponent{{?? tps.answers.component }}{{= tps.answers.component }}{{??}}div{{?}}>
	)
};
```

</Dot>

lastly is no answer was given for `component` then it would default to a `div`

<Dot
	tps={{name: "react-component"}}
	lang="tsx"
	templateMeta='{3}'
	displayTemplate={false}
>

```text
const App = () => {
	return (
		<{{? tps.answers.component === 'page' }}PageComponent block{{?? tps.answers.component }}{{= tps.answers.component }}{{??}}div{{?}}>
			/* contents... */
		</{{? tps.answers.component === 'page' }}PageComponent{{?? tps.answers.component }}{{= tps.answers.component }}{{??}}div{{?}}>
	)
};
```

</Dot>

</TabItem>
</Tabs>

Checkout our [API docs](../../api/template-engine/conditionals) for more
examples on how you can take advantage of conditionals

### Loops

Loops are achieved using the `~` operator along with inline or block brackets.
The contents of the loop will be rendered into the output of the file for each
item of the array

<Tabs>
<TabItem value="block" label="Block">

Take this template using a block loop statement to render import statements to
the react file when `modules` is specified.

<Dot
	tps={{answers: { modules: ["utils", "pages"] }}}
	lang='tsx'
>

```text
import React from 'react';
{{{~tps.answers.modules :value}}}
import {{= value}} from "@app/{{= value}}";
{{{~}}}
```

</Dot>

</TabItem>

<TabItem value="inline" label="Inline">

<Dot>

```text
{{~[1, 2, 3, 4] :value:index}}{{= value}}{{~}}
```

</Dot>

</TabItem>
</Tabs>

:::tip

If you dont need anything to complex, then use `join`!

<Dot>

```text
{{= [1,2,3,4].join("\n")}}
```

</Dot>

:::

Checkout our [API docs](../../api/template-engine/loops) for more examples on
how you can take advantage of loops

### Defs (Partials)

DoT supports defs (partials). Defs allow you to create reusable sections of a
templates. Think of them as smaller templates that can be defined separately and
then included within larger templates. This provides modularity and simplifies
the process of maintaining and updating your templates.

<Tabs>
<TabItem value="block" label="Block">

<Dot>

```text
{{{##def.intro:
This is my intro
#}}}
{{#def.intro}}
```

</Dot>

</TabItem>

<TabItem value="inline" label="Inline">

<Dot>

```text
{{##def.intro:
This is my intro
#}}

{{#def.intro}}
```

</Dot>

</TabItem>
</Tabs>

#### Args

<Tabs>
<TabItem value="block" label="Block">

<Dot>

```text
{{{##def.intro:
This is my intro
#}}}
{{#def.intro}}
```

</Dot>

</TabItem>

<TabItem value="inline" label="Inline">

<Dot>

```text
{{##def.intro:
This is my intro
#}}

{{#def.intro}}
```

</Dot>

</TabItem>
</Tabs>

#### Functions

You can also define functions as defs

<Tabs>
<TabItem value="block" label="Block">

<Dot>

```text
{{{##def.intro = function(name) {
		return `This is my intro`;
}#}}}
{{#def.intro()}}
```

</Dot>

</TabItem>

<TabItem value="inline" label="Inline">

<Dot>

```text
{{##def.intro = function(name) {
		return `This is my intro`;
}#}}
{{#def.intro()}}
```

</Dot>

</TabItem>
</Tabs>

---

## How to utilize the template engine

There are three main ways to use our template engine to make your template
dynamic, in [files names](#file-names), [file contents](#file-contents), and
[def files](#def-files)

### File names

Every file within your template can leverage the capabilities of the template
engine directly within its file name. This enables dynamic naming of files when
a new instance of template is being created.

<Example open>

If you had a template named `react-component` and had a file in the template
named `{{=tps.name}}.js` like the following:

```text
| - .tps/
	| - react-component
		| - default
			| - {{=tps.name}}.js
```

Now if you rendered a new instance of this template named `App`:

```bash
tps react-component App
```

then youll end up with:

```text
| - App/
	| - App.js
```

</Example>

Any functionality of our template engine can be used in files names, however
here are some common use cases that we use when we build templates

<Tabs>

<TabItem value="interpolation" label="Interpolation">

```text
{{= tps.name}}.js
```

If `name` was `Nav` then the result would be:

```text
Nav.js
```

</TabItem>

<TabItem value="utils" label="utils">

```text
{{= tps.utils.camelCase(tps.name)}}.js.dot
```

If `name` was `my-nav` then the result would be:

```text
myNav.js
```

</TabItem>

<TabItem value="defs" label="Defs">

you can utilize a def if your logic gets to complex for your file name

:::caution

Be aware that adding new lines to the def file will also show up in your file
name

:::

```txt title="name.def"
{{? tps.answers.capitalize}}{{= tps.utils.capitalize(tps.name)}}{{??}}tps.name{{?}}
```

```text
{{#def.name}}.js
```

If `name` was `nav` and `capitalize` was true then the result would be:

```text
Nav.js
```

if `capitalize` was false then the result would be:

```txt
nav.js
```

</TabItem>

</Tabs>

### File contents

Like mentioned above, once you add a `.dot` extention to your file name you are
now able to use any dot syntax inside the file and tps will process it.

<Dot lang="js" templateName="server.js.dot" tps={{answers: { security: true }}}>

```text
const express = require("express");
{{{? tps.answers.security }}}
const helmet = require("helmet");
{{{?}}}

const app = express();
{{{? tps.answers.security }}}

app.use(helmet());
{{{?}}}

/* node code ... */
```

</Dot>

### Def files

Templates allows you to define doT defs inside files for easier use. Def files
gets loaded before any files are rendered so you have access to all defs you
define inside your template files.

Def files are files inside your packages that have a `.def` extension.

<Example>

```text
| - .tps/
	| - react-component
		| - default/
			| - helpers.def
```

</Example>

If you want your def files to be accessable anywhere put them inside your
`default` package. If your def file is only used inside a specific package then
place it inside that package

:::caution

def files placed inside packages may be usable inside template files inside
other packages, however this is discouraged and may not be supported in other
versions

:::

Def files can be used in two ways:

#### single def file

If your def file has no dot syntax then the whole file will be converted to a
`def`. You can access this def inside your template files by using
`{{#def.<file-name>}}`

<Example>

If you had this template folder structure:

```text
| - .tps/
	| - some-template/
		| - default/
			| - helpers.def
			| - index.txt.dot
```

and inside your `helpers.def` you had:

```text
This is my def file
```

and inside `index.txt.dot` you had:

```txt
hey there
{{#def.helpers}}
```

Your rendered `index.txt` file would end up like this:

```txt
hey there
This is my def file
```

</Example>

#### multiple def functions inside a file

You can define multiple def functions inside a def file by using the def syntax
`{{##def.name: ... #}`. These def files can be accessed by the name you give
them in the def.

<Example>

If you had this template folder structure:

```text
| - .tps/
	| - some-template/
		| - default/
			| - helpers.def
			| - index.txt.dot
```

and inside your `helpers.def` you had:

```text
{{##def.helper1:
helper 1
#}}

{{##def.helper2:
helper 2
#}}
```

and inside `index.txt.dot` you had:

```txt
hey there
{{#def.helper1}}
{{#def.helper2}}
```

Your rendered `index.txt` file would end up like this:

```txt
hey there
helper 1
helper 2
```

</Example>

## Templates Context

After converting a file to use doT, you gain access to the templates context
object, which contains information about the template and rendering metadata. To
utilize the context object, you can refer to the tps object within doT tags.
Here's an example:

```text
{{ tps }}
```

Now, let's explore some of the most commonly used properties available in this
object. For a full list, you can refer to the
[tps context API](../../api/template-context).

### Name

```text
{{= tps.name }}
```

Name of new instance you are rendering. When rendering two or more instances at
the same time. The same concept as above apply's but for each path you pass in.

If you generate a new instance of a template with no build path. Then `tps.name`
will be null.

<Example>

```bash title="cli"
tps react-component Nav
```

<Dot tps={{ name: "Nav" }}>

```text
const {{= tps.name}} = (props) => {
	return (
		<div></div>
	)
}
```

</Dot>

</Example>

:::tip

Dont remember what the template name is? Refresh your mind
[here](./templates#single-build-path)

:::

---

### Packages

```text
{{= tps.packages }}
```

List of packages that were used when rendering your template.

:::tip

Remember `default` package is include by default

:::

When no additional packages are used:

```json
["default"]
```

when additional packages are used:

```json
["default", "css", "unit-tests"]
```

<Example>

<Tabs>
<TabItem value="Additional packages">

```bash title="cli"
tps react-component App --packages css
```

<Dot tps={{name: "Nav", packages: ['default', "css"]}} lang="js">

```text
import React from react;
{{? tps.packages.includes("css")}}import "{{= tps.name}}.css";
{{?}}
const {{= tps.name}} = (props) => {
	return (
		<div></div>
	)
}

```

</Dot>

</TabItem>

<TabItem value="No additional packages">

```bash title="cli"
tps react-component App
```

<Dot tps={{name: "Nav", packages: ['default']}} lang="js">

```text
import React from react;
{{? tps.packages.includes("css")}}import "{{= tps.name}}.css";
{{?}}
const {{= tps.name}} = (props) => {
	return (
		<div></div>
	)
}

```

</Dot>

</TabItem>
</Tabs>

</Example>

:::tip

Don't remember how to use packages? Refresh your mind [here](./packages)

:::

### utils

```text
{{= tps.utils }}
```

Make your template creation journey more enjoyable with our collection of
utilities. We've integrated powerful tools from
[change-case](https://www.npmjs.com/package/change-case) and
[inflection](https://www.npmjs.com/package/inflection) to streamline your
workflow.

here are a list of some:

- [camelCase](../../api/template-context#camelCase)
- [capitalCase](../../api/template-context#capitalCase)
- [constantCase](../../api/template-context#constantCase)
- [dotCase](../../api/template-context#dotCase)
- [headerCase](../../api/template-context#headerCase)
- [paramCase](../../api/template-context#paramCase)
- [pascalCase](../../api/template-context#pascalCase)
- [snakeCase](../../api/template-context#snakeCase)
- [pluralize](../../api/template-context#pluralize)
- [singularize](../../api/template-context#singularize)
- [camelize](../../api/template-context#camelize)
- [underscore](../../api/template-context#underscore)
- [humanize](../../api/template-context#humanize)
- [capitalize](../../api/template-context#capitalize)

To explore all the available functions, check out the
[tps context utils API](../../api/template-context#utils).

<Example>

```bash title="cli"
tps react-component nav
```

<Dot tps={{name: "nav", packages: ['default']}} lang="js">

```text
import React from react;

const {{= tps.utils.capitalize(tps.name)}} = (props) => {
	return (
		<div></div>
	)
}
```

</Dot>

</Example>
