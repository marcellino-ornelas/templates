---
pagination_next: main/create-new-template/settings
pagination_prev: main/create-new-template/packages
sidebar_position: 3
---

import { Example } from '@site/docs/components/example';
import { Dot } from '@site/docs/components/dot';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Dynamic Files

:::caution

If you not using a version of templates above `1.1.0`, please refer to the
[legacy docs](./dynamic-files-legacy)

:::

## Dynamic files breakdown

Dynamic file are files that can be rendered with dynamic data. You can think of
these files sort of like how template engines work. You use a special syntax
than then gets replaced with data you provide. This output then gets saved into
the file where this instance is being generated.

<Example open>

A file with these contents

```text
{{{= tps.answers.name }}} wants some more cake
```

will produce:

```text
lino wants some more cake
```

Dont worry about the specifics, well touch more on the syntax later on this page

</Example>

## Template engine

Like mentioned before our in house template engine was forked from
[doT](http://olado.github.io/doT/index.html). However we add some more
capabilities in order to fit templates needs better.

mention: strictness of white space

Our template engine has two main syntaxes: `inline` and `block`

### Inline syntax

Inline syntax is implemented using two curly brackets at both the start and end
of your expression `{{ ... }}`. This syntax is more flexable and recommended
when dealing with different control flows inline.

Take this template that is using a inline if statement to conditionally add a
typescript type to the variable.

<Dot
	tps={{ 
		answers: {
			typescript: true,
		},
	}}
	lang="typescript"
>

```
const name{{? tps.answers.typescript }}: string{{?}} = 'lino';
```

</Dot>

### Block syntax

Block syntax is implemented using three curly brackets at both the start and end
of your expression `{{{ ... }}}`. The main differences is that block syntax
needs to be placeds on a new line and it will remove all white space in front
and behind the brackets completely removing the line from output.

Take this example using a block if statement, when `css` is `false` notice how
there no is trace that anything was there before, no new lines, no spaces,
nothing it was completely wiped.

<Dot
	tps={{ 
		answers: {
			css: false
		}
	}}
	lang="typescript"
>

```
import React from 'react';
{{{? tps.answers.css }}}
import './component.css';
{{{?}}}
```

</Dot>

You can also indent block syntax and all tabs and spaces will be removed

<Dot
	tps={{ 
		answers: {
			css: false
		}
	}}
	lang="typescript"
>

```
const App = () => {
	{{{? tps.answers.state }}}
	const [state, setState] = useState(null);
	{{{?}}}

	return (
		/* other code ... */
	)
}
```

</Dot>

<Example title='Why is there inline and block?'>

Block syntax plays a special role in file generation. By removing all existence
of white space, your rendered output looks nice and clean. Templates aims to not
only make development eaiser but also enforce standards.

Before block syntax there was only inline syntax, however there was a lot of
issues with the way these tags got parsed that left outputed files with
unindented whitespace.

**example:**

lets use the example template from above and change block syntax to inline
syntax. Now when `css` & `state` are `false`, notice how there is extra
whitespace behind

<Dot
	tps={{ 
		answers: {
			css: false,
			state: false
		}
	}}
	lang="typescript"
	resultMeta="{2,5}"
>

```
import React from 'react';
{{? tps.answers.css }}
import './component.css';
{{?}}

const App = () => {
	{{? tps.answers.state }}
	const [state, setState] = useState(null);
	{{?}}

	return (
		/* other code ... */
	)
}
```

</Dot>

Now when `css` & `state` are `true`, you can also see extra lines.

<Dot
	tps={{ 
		answers: {
			css: true,
			state: true
		}
	}}
	lang="typescript"
	resultMeta="{2,7,9}"
	displayTemplate={false}
>

```
import React from 'react';
{{? tps.answers.css }}
import './component.css';
{{?}}

const App = () => {
	{{? tps.answers.state }}
	const [state, setState] = useState(null);
	{{?}}

	return (
		/* other code ... */
	)
}
```

</Dot>

In order to get the perfect output, you needed to sacrafice the readability of
the template and do something like the following:

<Dot
	tps={{ 
		answers: {
			css: false,
			state: false
		}
	}}
	lang="typescript"
>

```
import React from 'react';
{{? tps.answers.css }}import './component.css';
{{?}}
const App = () => {
	{{? tps.answers.state }}const [state, setState] = useState(null);
	{{?}}
	return (
		/* other code ... */
	)
}
```

</Dot>

Now when `css` & `state` are `true`, you can also see extra lines.

<Dot
	tps={{ 
		answers: {
			css: true,
			state: true
		}
	}}
	lang="typescript"
	displayTemplate={false}
>

```
import React from 'react';
{{? tps.answers.css }}import './component.css';
{{?}}
const App = () => {
	{{? tps.answers.state }}const [state, setState] = useState(null);
	{{?}}
	return (
		/* other code ... */
	)
}
```

</Dot>

While this might not look the worst for one answer, imagine 3 or 4. Now lets see
how block syntax improves this:

<Dot
	tps={{ 
		answers: {
			css: false,
			state: false,
		}
	}}
	lang="typescript"
>

```
import React from 'react';
{{{? tps.answers.css }}}
import './component.css';
{{{?}}}

const App = () => {
	{{{? tps.answers.state }}}
	const [state, setState] = useState(null);
	{{{?}}}

	return (
		/* other code ... */
	)
}
```

</Dot>

Now when `css` & `state` are `true`,

<Dot
	tps={{ 
		answers: {
			css: true,
			state: true,
		}
	}}
	lang="typescript"
	displayTemplate={false}
>

```
import React from 'react';
{{{? tps.answers.css }}}
import './component.css';
{{{?}}}

const App = () => {
	{{{? tps.answers.state }}}
	const [state, setState] = useState(null);
	{{{?}}}

	return (
		/* other code ... */
	)
}
```

</Dot>

</Example>

## Template Syntaxes

### Evaluation

Evaluation is achieved using `{{ <expression> }}`. The `expression` can be any
valid JavaScript expression. You can create variables, functions, and etc. **The
semi-colon at the end of the expression is mandatory!**

While you can use inline experessions, we recommned using block expressions.

<Tabs>
<TabItem value="block" label="Block">
</TabItem>

<TabItem value="inline" label="Inline">
</TabItem>
</Tabs>

---

<Tabs>
<TabItem value="block" label="Block">

<Dot>

```text
{{{ const name = "Marcellino Ornelas"; }}}

{{{= name }}}
```

</Dot>

</TabItem>

<TabItem value="inline" label="Inline">

<Dot>

```text
{{const name = "Marcellino Ornelas";}}
Hey
```

</Dot>

</TabItem>
</Tabs>

### Interpolation

In doT, interpolation is achieved using `{{= <expression>}}`. This syntax allows
the result of the specified expression to replace the brackets in the template.

<Tabs>
<TabItem value="block" label="Block">

<Dot>

```text
{{{= 2 + 2}}}
```

</Dot>

</TabItem>

<TabItem value="inline" label="Inline">

<Dot>

```text
{{= 2 + 2}}
```

</Dot>

</TabItem>
</Tabs>

### Conditionals

In doT, interpolation is achieved using `{{? <expression>}} ... {{?}}`. The
result of the provided expression will be displayed if the expression returns
truthy value

<Tabs>
<TabItem value="block" label="Block">

<Dot>

```text
Are you there?
{{{? 1 === 1}}}
I am here
{{{?}}}
```

</Dot>

</TabItem>

<TabItem value="inline" label="Inline">

<Dot>

```text
Are you there? {{? 1 === 1}}I am here{{?}}
```

</Dot>

</TabItem>
</Tabs>

#### Else

You can also write else statements

<Tabs>
<TabItem value="block" label="Block">

<Dot>

```text
Are you there?
{{{? 1 !== 1}}}
I am here
{{{??}}}
I am not here
{{{?}}}
```

</Dot>

</TabItem>

<TabItem value="inline" label="Inline">

<Dot>

```text
Are you there? {{? 1 === 1}}I am here{{{??}}}I am not here {{?}}
```

</Dot>

</TabItem>
</Tabs>

#### If else

doT also supports else if statements.

<Tabs>
<TabItem value="block" label="Block">

<Dot>

```text
Are you there?
{{{? false }}}
I might be here
{{{?? true }}}
I am here
{{{?}}}
```

</Dot>

</TabItem>

<TabItem value="inline" label="Inline">

<Dot>

```text
Are you there? {{? 1 === 1}}I am here{{?}}
```

</Dot>

</TabItem>
</Tabs>

### Loops

In doT, loops is achieved using `{{~<array> :value:index}}{{= value}}{{~}}`.

<Tabs>
<TabItem value="block" label="Block">

<Dot>

```text
{{{~[1, 2, 3, 4] :value:index}}}
{{= value}}
{{{~}}}
```

</Dot>

<Dot>

```text
{{{~[1, 2, 3, 4] :value:index}}}{{= value}}{{{~}}}
```

</Dot>

</TabItem>

<TabItem value="inline" label="Inline">

<Dot>

```text
{{~[1, 2, 3, 4] :value:index}}{{= value}}{{~}}
```

</Dot>

</TabItem>
</Tabs>

Unfortunately we need to keep all tags on the same line to get a cleaner output.
By indenting `{{= value}}` to get a cleaner look will result in indent in the
rendered output

<Example title="Indent Issues">

<Dot>

```text
{{~[1, 2, 3, 4] :value:index}}
	{{= value}}
{{~}}
```

</Dot>

</Example>

:::tip

If you dont need anything to complex, then use `join`!

<Dot>

```text
{{= [1,2,3,4].join("\n")}}
```

</Dot>

:::

### Defs (Partials)

DoT supports defs (partials). Defs allow you to create reusable sections of a
templates. Think of them as smaller templates that can be defined separately and
then included within larger templates. This provides modularity and simplifies
the process of maintaining and updating your templates.

<Tabs>
<TabItem value="block" label="Block">

<Dot>

```text
{{{##def.intro:
This is my intro
#}}}
{{#def.intro}}
```

</Dot>

</TabItem>

<TabItem value="inline" label="Inline">

<Dot>

```text
{{##def.intro:
This is my intro
#}}

{{#def.intro}}
```

</Dot>

</TabItem>
</Tabs>

#### Args

<Tabs>
<TabItem value="block" label="Block">

<Dot>

```text
{{{##def.intro:
This is my intro
#}}}
{{#def.intro}}
```

</Dot>

</TabItem>

<TabItem value="inline" label="Inline">

<Dot>

```text
{{##def.intro:
This is my intro
#}}

{{#def.intro}}
```

</Dot>

</TabItem>
</Tabs>

#### Functions

You can also define functions as defs

<Tabs>
<TabItem value="block" label="Block">

<Dot>

```text
{{{##def.intro = function(name) {
		return `This is my intro`;
}#}}}
{{#def.intro()}}
```

</Dot>

</TabItem>

<TabItem value="inline" label="Inline">

<Dot>

```text
{{##def.intro = function(name) {
		return `This is my intro`;
}#}}
{{#def.intro()}}
```

</Dot>

</TabItem>
</Tabs>

---

## How to utilize the template engine

There are three main ways to use our template engine to make your template
dynamic, in [files names](#file-names), [file contents](#file-contents), and
[def files](#def-files)

### File names

Every file within your template can leverage the capabilities of the template
engine directly within its file name. This enables dynamic naming of files when
a new instance of template is being created.

<Example open>

If you had a template named `react-component` and had a file in the template
named `{{=tps.name}}.js` like the following:

```text
| - .tps/
	| - react-component
		| - default
			| - {{=tps.name}}.js
```

Now if you rendered a new instance of this template named `App`:

```bash
tps react-component App
```

then youll end up with:

```text
| - App/
	| - App.js
```

</Example>

Any functionality of our template engine can be used in files names, however
here are some common use cases that we use when we build templates

<Tabs>

<TabItem value="interpolation" label="Interpolation">

```text
{{= tps.name}}.js
```

If `name` was `Nav` then the result would be:

```text
Nav.js
```

</TabItem>

<TabItem value="utils" label="utils">

```text
{{= tps.utils.camelCase(tps.name)}}.js.dot
```

If `name` was `my-nav` then the result would be:

```text
myNav.js
```

</TabItem>

<TabItem value="defs" label="Defs">

you can utilize a def if your logic gets to complex for your file name

:::caution

Be aware that adding new lines to the def file will also show up in your file
name

:::

```txt title="name.def"
{{? tps.answers.capitalize}}{{= tps.utils.capitalize(tps.name)}}{{??}}tps.name{{?}}
```

```text
{{#def.name}}.js
```

If `name` was `nav` and `capitalize` was true then the result would be:

```text
Nav.js
```

if `capitalize` was false then the result would be:

```txt
nav.js
```

</TabItem>

</Tabs>

### File contents

Like mentioned above, once you add a `.dot` extention to your file name you are
now able to use any dot syntax inside the file and tps will process it.

<Example open>

<Dot lang="js" templateName="server.js.dot" tps={{answers: { security: true }}}>

```text
const express = require("express");

const app = express();

/* node code ... */

{{? tps.answers.security }}app.use(helmet());{{?}}

/* node code ... */
```

</Dot>

</Example>

### Def files

Templates allows you to define doT defs inside files for easier use. Def files
gets loaded before any files are rendered so you have access to all defs you
define inside your template files.

Def files are files inside your packages that have a `.def` extension.

<Example>

```text
| - .tps/
	| - react-component
		| - default/
			| - helpers.def
```

</Example>

If you want your def files to be accessable anywhere put them inside your
`default` package. If your def file is only used inside a specific package then
place it inside that package

:::caution

def files placed inside packages may be usable inside template files inside
other packages, however this is discouraged and may not be supported in other
versions

:::

Def files can be used in two ways:

#### single def file

If your def file has no dot syntax then the whole file will be converted to a
`def`. You can access this def inside your template files by using
`{{#def.<file-name>}}`

<Example>

If you had this template folder structure:

```text
| - .tps/
	| - some-template/
		| - default/
			| - helpers.def
			| - index.txt.dot
```

and inside your `helpers.def` you had:

```text
This is my def file
```

and inside `index.txt.dot` you had:

```txt
hey there
{{#def.helpers}}
```

Your rendered `index.txt` file would end up like this:

```txt
hey there
This is my def file
```

</Example>

#### multiple def functions inside a file

You can define multiple def functions inside a def file by using the def syntax
`{{##def.name: ... #}`. These def files can be accessed by the name you give
them in the def.

<Example>

If you had this template folder structure:

```text
| - .tps/
	| - some-template/
		| - default/
			| - helpers.def
			| - index.txt.dot
```

and inside your `helpers.def` you had:

```text
{{##def.helper1:
helper 1
#}}

{{##def.helper2:
helper 2
#}}
```

and inside `index.txt.dot` you had:

```txt
hey there
{{#def.helper1}}
{{#def.helper2}}
```

Your rendered `index.txt` file would end up like this:

```txt
hey there
helper 1
helper 2
```

</Example>

## Templates Context

After converting a file to use doT, you gain access to the templates context
object, which contains information about the template and rendering metadata. To
utilize the context object, you can refer to the tps object within doT tags.
Here's an example:

```text
{{ tps }}
```

Now, let's explore some of the most commonly used properties available in this
object. For a full list, you can refer to the
[tps context API](../../api/template-context).

### Name

```text
{{= tps.name }}
```

Name of new instance you are rendering. When rendering two or more instances at
the same time. The same concept as above apply's but for each path you pass in.

If you generate a new instance of a template with no build path. Then `tps.name`
will be null.

<Example>

```bash title="cli"
tps react-component Nav
```

<Dot tps={{ name: "Nav" }}>

```text
const {{= tps.name}} = (props) => {
	return (
		<div></div>
	)
}
```

</Dot>

</Example>

:::tip

Dont remember what the template name is? Refresh your mind
[here](./templates#single-build-path)

:::

---

### Packages

```text
{{= tps.packages }}
```

List of packages that were used when rendering your template.

:::tip

Remember `default` package is include by default

:::

When no additional packages are used:

```json
["default"]
```

when additional packages are used:

```json
["default", "css", "unit-tests"]
```

<Example>

<Tabs>
<TabItem value="Additional packages">

```bash title="cli"
tps react-component App --packages css
```

<Dot tps={{name: "Nav", packages: ['default', "css"]}} lang="js">

```text
import React from react;
{{? tps.packages.includes("css")}}import "{{= tps.name}}.css";
{{?}}
const {{= tps.name}} = (props) => {
	return (
		<div></div>
	)
}

```

</Dot>

</TabItem>

<TabItem value="No additional packages">

```bash title="cli"
tps react-component App
```

<Dot tps={{name: "Nav", packages: ['default']}} lang="js">

```text
import React from react;
{{? tps.packages.includes("css")}}import "{{= tps.name}}.css";
{{?}}
const {{= tps.name}} = (props) => {
	return (
		<div></div>
	)
}

```

</Dot>

</TabItem>
</Tabs>

</Example>

:::tip

Don't remember how to use packages? Refresh your mind [here](./packages)

:::

### utils

```text
{{= tps.utils }}
```

Make your template creation journey more enjoyable with our collection of
utilities. We've integrated powerful tools from
[change-case](https://www.npmjs.com/package/change-case) and
[inflection](https://www.npmjs.com/package/inflection) to streamline your
workflow.

here are a list of some:

- [camelCase](../../api/template-context#camelCase)
- [capitalCase](../../api/template-context#capitalCase)
- [constantCase](../../api/template-context#constantCase)
- [dotCase](../../api/template-context#dotCase)
- [headerCase](../../api/template-context#headerCase)
- [paramCase](../../api/template-context#paramCase)
- [pascalCase](../../api/template-context#pascalCase)
- [snakeCase](../../api/template-context#snakeCase)
- [pluralize](../../api/template-context#pluralize)
- [singularize](../../api/template-context#singularize)
- [camelize](../../api/template-context#camelize)
- [underscore](../../api/template-context#underscore)
- [humanize](../../api/template-context#humanize)
- [capitalize](../../api/template-context#capitalize)

To explore all the available functions, check out the
[tps context utils API](../../api/template-context#utils).

<Example>

```bash title="cli"
tps react-component nav
```

<Dot tps={{name: "nav", packages: ['default']}} lang="js">

```text
import React from react;

const {{= tps.utils.capitalize(tps.name)}} = (props) => {
	return (
		<div></div>
	)
}
```

</Dot>

</Example>
